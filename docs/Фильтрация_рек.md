## 1. Фильтрация по атрибутам  

* На вход подается QgsVectorLayer рек, словарь фильтров: `filters: {<поле>: (<оператор>, <значение>)}`. 
* Для каждого `(fld, (op, val))` формируем строку `"<fld>" <op> <val_repr>`, где строковые `val` экранируются (`'` → `''`). 
* Собираем SQL-выражение `expression = " AND ".join(expr_parts)`; если пусто – `TRUE`.
* Вызываем QGIS-процессинг `native:extractbyexpression` с `INPUT = rivers_layer`, `EXPRESSION = {собранная строка}`, `OUTPUT = TEMPORARY_OUTPUT`. Получаем временный слой с отфильтрованными звеньями (stream segments).


## 2. Вычисление порядка Страллера

Чтобы вычислить порядок Стралера, сеть нужно представить в виде ориентированного ациклического графа:
* Узлы (nodes) — координаты развилок, истоков и устьев сегментов: (x, y) парой.
* Рёбра (edges) — сами речные отрезки, ориентированные «по течению» (от истока к устью).

Алгоритм построения:
1. Получаем координаты начала `(sx, sy, sz)` и конца `(ex, ey, ez)`.
2. Если `sz < ez`, меняем начало и конец местами, чтобы поток шёл вниз.
3. Каждой уникальной паре `(x, y)` присваиваем `node_id` через `node_map`.
4. Собираем рёбра `edges = [(node_from, node_to, feature_id), …]`.

Правила Стралера:
* Порядок истокового сегмента = 1.
* При слиянии двух притоков с порядками $p_1$ и $p_2$:
    * если $p_1$ = $p_2$ = m → новый порядок = m + 1;
    * иначе → max($p_1$, $p_2$).

Реализация:
* Строим словари для каждого узла:
```python
incoming[node]   # список рёбер по течению (upstream)
outgoing[node]   # список рёбер против течения (downstream)
```
* Используем рекурсивную функцию calc_edge:
    * Если у current_node нет входящих рёбер → order = 1.
    * Иначе вычислить order всех upstream-сегментов, применить правило Стралера.
* Делаем обход начиная с устьевых узлов и поднимаемся против течения.

## 3. Расчёт длины сегментов

* Добавляем в слой новое поле length и вычислить через QGIS-формулу `$length` — геометрическая длина каждой сегмента в текущей CRS.
* Суммируем все длины для сегментов одной сети.